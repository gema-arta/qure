Booting
=======

Bootsector:

16 bit real mode, uses BIOS to load more sectors (sector1).


Sector1:

16 bit real mode entry point.
Currently implements calls to BIOS.



Protected Mode:

I wonder whether calling 16 bit code (with a far return) is possible
in protected mode. The segment is marked 16 bit, and thus the instructions
are interpreted as such. As long as no segment changes are done...

Check v8086 mode, and real-mode gates to call bios, until the OS
can interact with the chipsets directly.

============================================

Idea 1: have 16, 32 and 64 bit kernels loaded. Rename bootloader to 16 bit kernel.

=======================================


KFS - Kernel File System
------------------------

Attempts to solve the loadable module problem: code suitable for modules,
such as ATA drivers, would need to be loaded using the BIOS, and thus
be part of the kernel image.

The solution is to export a Kernel File System that appears at a mount
point in the root filesystem. This is not required for ISO9660 images,
but is nice for HDD.

- Loadable Modules -

The advantage of having a module is that the code can be independently compiled
and updated from the kernel. Thus, higher programming languages can be used.

- Backward compatability -

As with the BIOS loading the bootsector, which uses the BIOS to load
the rest of the bootloader, which then loads the kernel, 
so does the kernel load it's modules.

The current approach is to have the (boot) loader implement a simple filesystem
that follows the loader image in the next sector on disk. 
The bootloader loads the first image within the filesystem.

	------------------
	Bootsector 
	  load bootloader
	------------------
	Bootloader
	  Gather BIOS info
	  load first ramdisk image
	------------------
	RAMDISK header
	  (offset,length)*
	---------------
	Kernel
	  realmode
	    16 bit code to switch to pmode
	    32 bit pmode init code
	      gdt, idt, pic, pit, keyboard
	  ----
	  kmain
	    pci
	    bios
	    cmos
	    ata
	    (shell)
	    (iso9660)
	---------------

The new idea is then this:

	==============
	bootsector
	==============
	bootloader
	==============
	RAMDISK header
	==============
	First RAMDISK image
	  -----------
	  Kernel
	    realmode
	    pmode
	    init preloaded modules
	  -----------
	  KFS Header
	  -----------
	    ata
	  -----------
	    iso9660
	  -----------
	==============  
	    pci
	  -----------


	/kfs
	  modules/

Approach 1 is to have a loaded/, unloaded/, preloaded/, and loadonstart/
directories. One could do a  mv loaded/foo.mod unloaded/.

Approach 2 is to have a preload/ and loaded/ directories,
where putting a module in the preload/ will change the kernel image which
contains the first few modules. To load a module, move or copy it to the
loaded/ folder - when load is triggered and fails, the file will not be there.
To unload a module simply delete it from loaded/.

Approach 3 is to assign attributes to the module files.
To load a module:  chmod +x module    Unload: chmod -x
To auto-load a module: chmod +r module
To make a module preload: chmod +w module
Or perhaps other types of attributes...

There should be no need to mark the order in which modules should be loaded,
as their binary form should indicate what libraries are required. Each
module then exports some API functionality as a library with the same name
as the kernel. 

Another approach is to have the dependency and order information stored
in the KFS itself. 


	============
	Bootsector
	============
	Bootloader
	============
	KFS Header
	-----------
	  kernel image
	  module*
	============

The bootloader would have a minimal 16 bit KFS implementation.
Images would be marked as a kernel, allowing for several versions of
the kernel.


When booting from CDROM there is little use for KFS, as some modules,
including the KFS code, would need to be on the emulated floppy image,
and some others in the ISO9660 filesystem.

The CDROM filesystem itself allows for re-use of the same data.

On the harddisk, the partition (if those are used at the bios level)
can reserve some space for the kernel and the modules. This space
is accessed then using the KFS, which preserves an ordering of the data
that is usable by the bootloader, i.e., contiguous sectors for all files,
and keeping the bootsector and bootloader in defined places.

The bootsector itself might even use the KFS header to find the bootloader.


So:

Sector 0: bootsector
Sector 1: KFS header
Sector 2..N: bootloader, kernel image, and modules.

The KFS header then has 4 types of files to manage:
- bootloader (around 5 sectors)
- kernel (43kb)
- modules
- other

Special boot entry sections need to be recorded, where it is specified
what modules to load for a certain kernel version.


Using the MBR approach, the KFS can be anywhere on the disk.


KFS Header:
  Bootloader location (RBA/LBA, sectors)
  Kernel | Module


If the KFS is always the sector following the bootsector,
the data for the bootloader location can be stored in the bootsector,
as it is now.

Approach then:
- update the bootloader (sector1) code to work from RAMDISK to KFS.
- bootloader is not passed information whether it is the MBR or a partition
- thus the absolute CHS/LBA needs to be recorded in the bootsector.


Currently the bootsector:
- knows at compiletime the size of the bootloader,
- finds the first bootable partition,
- assumes it is sector0 of that partition,
- and loads the rest of the bootloader.

The idea is to keep the code for both loaders the same, so, the Partition Table
must serve a different purpose depending on whether the bootsector is the MBR
or not.

Since officially only values 0 and 128 are allowed for the status byte
in a partition table entry, using other values here to indicate the bootsector
resides in a partition allows to reuse the partition table data to indicate
the location and size of the bootloader code, instead of chainloading.



Memory Mapping / Flat
=====================
At current, the kernel uses relative (non-flat) selectors.
This is conventient because the kernel selectors are set to the minimum
required size (for both code and data) to operate.
The code selector begins at the kernel code start, and ends at the code end,
thus preventing the kernel from executing code outside it's defined code.

Paging
------
Tasks with their own paging structures can (and will) use flat selectors.
Calling library functions then poses a problem, as these functions are
implemented in kernel space, which uses relative selectors, whereas
the task uses flat selectors.
The printf function, for instance, takes a variable amount of stack
arguments, some of which may be pointers. Having replaced ds with the kernel
ds for referencing kernel data, the user data must be converted. This would
mean to either parameterize the printf function with a pointer-delta
to be applied, or to have two versions.
Further, the stack selector may or may not be flat, and thus copying data
from/to stack can be problematic. A flat-mem task will have a flat ss,
and kernel/libc.s setregs$ only changes cs, ds and es.

In short, kernel code expects data to be relative to cs (or ds/es).

Making the kernel flat-mem
--------------------------
This approach would prevent tasks from having another base as the kernel - the
problem is then reversed.
An easy way would be to do away with any relative selectors and rely more
heavily on paging.

One problem with specifying the '.org' for the 32 bit kernel code is that
the 16 bit code won't work anymore due to it being located beyond the 1mb range.

A temporary simple fix is to .org the kernel at the current load address (0x00013000),
however this address can change if the bootloader changes.

A more advanced fix is to extract the relocation information (or implement
COFF/ELF kernel loading in realmode). This is implemented in this commit.
The ramdisk entries are changed: the relocation table is inserted directly
after the kernel. It will appear to miss .data relocations due to the GAS -R
option (fold .data into .text).
The relocation table can be used by the kernel to modify itself once in protected
mode, and even copy itself to another address or change it's addressing scheme.

Kernel application dependent
----------------------------
The kernel as a service to tasks must establish agreements. One such agreement
is addressing.As shown, the kernel does not have to use the same address space
(the base of segment selectors), as it can convert, which is costly.

Paging
------
 The kernel will need access to user data which it will reference using addresses.
 Therefore, the kernel library will need to have those pages mapped and adressable
 using the pointers given by the application. 
 (to be really secure, a vararg method such as printf should evaluate all pointers
 to see if they refer to the task address space. Paging would allow this,
 by having a special mapping: the library code, it's static data, and the task.
 See [Paging|Paging.html] for more.)

Selector Overflow
-----------------
A technique that can be used to translate may be to use a selector overflow,
where the offset of the application, plus the selector base, exceeds the 4Gb limit
(not the selector limit) and wraps around. This appears to be used in linus' kernel.

An application expecting to be mapped at 0x0040000 would have a selector base
equal to the kernel's selectors (at current 0x0130000). The logical memory address
cs:0x0040000 then becomes the linear memory address 0x0053000. This solution
would require only to map the task's memory at that logical address. So far there
is no need for selector overflow, since the kernel is located before tasks.

The result of this will be, that the kernel will have a base relative to 0.
All memory below it is inaccessible, except using protected flat selectors.
It appears to be a useful feature, no doubt replicatable in other ways. However,
kernel libraries that take task pointers may not necessarily be able to be guaranteed
to be safe, as there is no way to distinguish a pointer to kernel memory from a
pointer to task memory that is hardware supported, except by using far pointers.
This would require a lot of segment register switching.

Security
--------
So far, we've seen that there is a memory area that can be completely protected
except by CPL0 code which can switch out for flat selectors.
Therefore, a secure kernel will have CPL0 code that does not use task provided
pointers. Ofcourse, the most obvious exception would be the scheduler.
Now, the above (the relative selector approach) will only work if selector overflow
does not reach the kernel data. Otherwise, if the kernel is located say at 1Mb,
then any task could use it's selectors to point to it by using offset -1Mb.
This should be able to be prevented by setting the selector limit below 4Gb.
Areas:

	0.....|selector base........|selector limit.......4Gb.

The selector limit could be -selector base, making the data after 4Gb (before the selector) inaccessible.

The scheduler allocates the task stack itself, and thus controls it. It's contents
will point to the task data initially, and may be set up by the task to attempt to
execute kernel code. Such calls (using pointers) only reside on a privileged stack.
The code is such, that data pointers are never used to execute code. This means,
that their contents are not decisive of what code is run, except as dictated
by kernel code, which only refers to kernel code. In other words, there is no
use of code-pointers controllable from task space through the stack.
The memory where code pointers are stored (static data) must be protected from write
access. 
Any code that writes to memory addresses passed on the stack should take extra care.
This care must be taken at the kernel api level. Functions such as printf pose
no modification threat but can expose the kernel. Read functions can potentially
overwrite the kernel.
Buffer read functions (character or block) can check simply if the memory address
given is from the task heap.


	ring0.s:			 +*   *) protected instructions:
		Code control GDT, IDT, TR+*   control registers: crX, drX, MSR, eflags
		  (CR, DR, GDT, IDT, TR)
		Memory (PaGing)		 +*
		TSS (IO)		 +*   -) not protected/privileged
		scheduler	(iret)	 +*
	ring1.s:			 +-   +) privileged memory access:
		IO drivers (raw data)	 +-	 paging distinguishes CPL0,1,2 from 3
	ring2.s:			 +-	 
		kernel tasks/API (fs,net)+-	 instructions operate on a CPL0 vs
	ring3.s:			 --	 1, 2, 3.
		unprivileged tasks	 --

The scheduler could use a popf,retf, and thus not require ring0, but it would
only be able to switch to a particular state (i.e., interrupts on).
THe privileged stack will be ring2.
The above leaves ring 1 and ring 2 identical in terms of memory access and
instruction availability. Here is where EFLAGS.IOPL is used: IOPL=1, therefore,
all drivers have access to all ports, just like ring0. This can be further
specified using the TSS.IO permissions, either by switching out TR in the
scheduler, or by updating the TSS IO field (which should take at most 4 memory
access per 32 IO ports, and at most 0x400 * 2).

At any ring, code will be able to switch out the code and stack selectors for one of
the same or lower privilege level. First the case where 'conforming' = 0 (i.e.,
the DPL must be the CPL, in other case, the CPL cannot change). This allows to
hide memory from lesser rings from higher rings (besides ring0).

Code control involves deciding what code to run when. It specifies, at first,
only it's own code to run at privilege level 0. All possible entrypoints that
are hardware detectable, such as interrupts and execution of certain kinds of
instructions and certain memory references or register changes, are configured
to execute ring0 kernel code. In short, exception handling.

Interrupt Handling
------------------
Next, there is interrupt handling, using another range of the interrupt table.
These are also captured by ring0 kernel code, but delegate to ring1 driver event
handlers. These are managed interrupts, as they are delivered to all tasks who
register a handler. Inter-task-communication could thus occur using such interrupts
by extending the range beyond the area reserved for IO device interrupts.

Task Detection
--------------
By registering an interrupt handler at MAX_IRQ + 1, a task could establish
communication with other tasks, as it is a broadcast channel.
The task would execute such a call by preparing it's register contents,
and issuing an interrupt. These interrupts can be configured to be allowable
at certain privilege levels in the IDT.
The first 19 interrupts are reserved for the kernel, as they are exception handlers.
The kernel determines when these are triggered, and therefore should not be used
directly by tasks, unless there is an agreement.
(See [ITC|ITC.html], legacy name: IPC)
