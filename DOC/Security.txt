

				ring 0: pmode, paging
				ring 1: scheduler, kernel api
				ring 2: drivers (IO)
				ring 3: unprivileged

* ring1:
  Both scheduler and kernel api have IOPL but do not use it. Ring 0 code is only
  executed through the kernel API, if needed.

* Ring 2:
  It seems to make sense to have drivers have less privilege than the
  kernel api itself, since drivers can be third party, since they are
  unprivileged due to not being ring0, yet have increased privilege only on
  the IO level aswell as memory access.
  The IO permission table can be configured per interrupt handler/driver,
  so that they only have access to the device and perhaps PCI. Ring 1 code does
  have access to all ports. A GPF handler can be installed to be handled
  by ring 1 code when ring2 attempts access, and this can either result in the
  driver being rejected, or masquerading the IO operations, such as PCI reads.
  It is however easier to provide a PCI api method.

* Ring 3:
  this code has no access to privileged pages and no IO access.

Drivers can reside in ring3, but then they have no access to ring 1 memory,
unless CR3 is switched out on IRQ and ring 2 API calls.

Ring3 processes have no access to ring2.

		CS DPL	Memory		DS DPL	IO
	Ring 0:	1 C	System		0 C	All
	Ring 1: 3 C	System		1 C	All
	Ring 2:	1 	System		2 NC	Partial
	Ring 3: 1 NC	Unprivileged	3 N/A	No

CS DPL: code able to execute privilege level change.
Ring 0 can only be called from ring 0 or ring 1.
Ring 1 can be called from 0-3.
Ring 2 can be called from ring 1 (so not other drivers in ring 2 or user code).
Ring 3 can only be called from ring 1 (scheduler, kernel api).

DS CPL:
Ring 0 is only accessible from ring 0.
Ring 1 only from ring 1, yet ring 0 is root, and thus always has access.
Ring 2 is only accessible from ring 2. Thus even the kernel api has to
go through elevation to access ring2 data through a ring2 selector. However,
the kernel api can be configured to have access to that memory. Ring 0
has unlimited data access.
Ring 3 is probably conforming ring 3, otherwise drivers cannot write in task
buffers.

Example
-------
Drivers must have access to all task buffers (disk read for instance).
Unprivileged task (3) calls the kernel API (1) to read from the file system.
The kernel API executes the driver (2), who reads into the task (3) memory.

Task buffers can be separated from task memory, since the kernel provides
all the memory addresses. The heap therefore, is distinct from the task image.
The driver API can be implemented as task gates, which do a stack and paging
switch. This paging switch allows to map only the task's heap into the driver
memory space. Further, there can be a kernel api to allocate buffers, besides
malloc. It would use the paging memory allocation system, instead. This way,
the kernel will know what memory addresses are buffers to be used for devices.

Another approach is to have the drivers use kernel memory. This way, a region
of memory can be mapped. It would have to then copy the data to the task space,
since it can use malloced memory, which is generally not page aligned.

NOTE: the scheduler must run at CPL0 if it switches out CR3, unless it uses
hardware task switching. In this case, the schedule_isr becomes a task gate.
It is not called as a task, because CR3 doesn't need switching unless another
task is scheduled to run. But it can set up the task switch TSS to be used
and jump through the hoop, avoiding iret. In this case it would not
pushall/popall, but rep movsd twice, not to mention the hardware overhead
(unless there is smart management of a dynamic array of TSS, where the most
run tasks' TSS is kept intact - TSS caching, as it were.)

Paging
------
The paging setup is done in CPL0, after which certain tables can be made
writable to the whole system (ring 0-2). Starting out with no page tables
writable, ring 1 code can ask to allocate a PDE or PTE, to be mapped in
the ring 1 memory space, which makes all memory accessible to it. It can
simply flush the paging TLB by doing a yield, or, since it is at the same
ring as the scheduler, can be given a task gate for this purpose.
There is no way using paging to indicate a difference between rings 0, 1 and2.
If they added just one more bit, it would have been.
To make ring 1 and 2 work, then, selectors must be used.
Allocating pages from end of memory down allows to limit the selectors for
rings 1 and 2. (Ring 3 limitation can done using paging). This makes
for a reserved region of memory at the end of memory. This can be done in
layers, each lower ring number having further access.

	Ring 0:	[0-4Gb]
	Ring 1: [2Mb-3Gb]
	Ring 2: [3Mb-2Gb]
	Ring 3: [4Mb-1Gb].

The kernel starts at 1Mb. The symbols 2Mb indicate the start of ring 0
code called by ring 1, followed by ring 1 code. 3Mb/4Mb idem.
This allows to separate code access. For data access on such granularity,
either each ring must be relocated independently, and thus far calls
are needed (allowing for stack switching aswell), or it must be done
on a paging level. This last approach has the downside, that the scheduler
at ring 1, must have control over task page memory. This cannot be directly
limited, since having a PDE or PTE at it's disposal, it can access any
memory. Therefore, this code must offer the table for validation before
the kernel enables it. This allows ring0 to provide both code and data
access protection of the kernel (as long as the ringed code and data
are page aligned).
